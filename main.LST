C51 COMPILER V9.01   MAIN                                                                  08/20/2016 14:19:38 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c COMPACT DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <reg51.h>
   2          #include "delay.h"
   3          #include "LCD1602.h"
   4          #include "I2C.h"
   5          #include "EEPROM.h"
   6          #include "NRF2401.h"
   7          #define GPIO_KEY P1
   8          #define DIG_GPIO_DUAN P3
   9          sbit LSA=P2^2;
  10          sbit LSB=P2^3;
  11          sbit LSC=P2^4;
  12          sbit NRF_IR  = P1^5;
  13          
  14          unsigned char rece_buf[32];
  15          unsigned char code DIG_PLACE[8]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};//ä½é€‰æ§åˆ¶   æŸ¥è¡¨çš„æ–¹æ³•
             -æ§åˆ¶
  16          unsigned char code DIG_CODE[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x7
             -9,0x71};  //0~Fçš„æ˜¾ç¤ºç 
  17          
  18          
  19          int main(void)
  20          {
  21   1        unsigned char count,i,flag_4=1; //flag_4è¯»å–æ ‡å¿—ä½ï¼Œé¿å…é‡å¤è¯»å–
  22   1      //  unsigned char rece_buf[32]="8>52103876cADf857";
  23   1        LCD1602_Init();// LCDåˆå§‹åŒ–
  24   1        while(NRF24L01_Check()); // ç­‰å¾…æ£€æµ‹åˆ°NRF24L01ï¼Œç¨‹åºæ‰ä¼šå‘ä¸‹æ‰§è¡Œ
  25   1        NRF24L01_RT_Init();
  26   1        LCD1602_Writestring("R");
  27   1        while(1)
  28   1        {
  29   2          if(NRF_IR==0)   // å¦‚æœæ— çº¿æ¨¡å—æ¥æ”¶åˆ°æ•°æ®
  30   2          {
  31   3            LCD1602_Writestring("I");
  32   3            if(NRF24L01_RxPacket(rece_buf)==0)
  33   3            {
  34   4              if(rece_buf[1]!='>')
  35   4              {
  36   5                sendstring("Please start with >\n");
  37   5              }
  38   4              else if(rece_buf[2]!='5'&&\
  39   4                      rece_buf[3]!='2'&&\
  40   4                      rece_buf[4]!='1'&&\
  41   4                      rece_buf[5]!='0'
  42   4                     )return -1;
  43   4              if(rece_buf[6]=='1')//æ˜¾ç¤ºå‘é€æ•°æ®å¹¶æŠŠæ•°æ®ä¿å­˜åˆ°EEPROMé‡Œé¢
  44   4              {
  45   5                LCD1602_Writestring("H");
  46   5                // sendstring("display and save data\n");
  47   5                LCD1602_Writestring("Write:");
  48   5                LCD1602_Writestring(rece_buf+7);//ä»ç¬¬ä¸ƒä½å¼€å§‹æ˜¾ç¤ºæ•°æ®,æŠŠç¬¬ä¸ƒä½çš„åœ°å€ä¼ ç»™æŒ‡é
             -’ˆ
  49   5                AT24C02_writestring(rece_buf+7);//ä»ç¬¬ä¸ƒä½å¼€å§‹ä¿å­˜æ•°æ®,æŠŠç¬¬ä¸ƒä½çš„åœ°å€ä¼ ç»™æŒ‡é
             -’ˆ
  50   5                flag_4=1;
  51   5              }
C51 COMPILER V9.01   MAIN                                                                  08/20/2016 14:19:38 PAGE 2   

  52   4              else if(rece_buf[6]=='2')//å±å¹•å·¦ç§»
  53   4              {
  54   5                  // sendstring("move left\n");
  55   5                  LCD1602_Writestring(rece_buf+7);//ä»ç¬¬ä¸ƒä½å¼€å§‹æ˜¾ç¤ºæ•°æ®,æŠŠç¬¬ä¸ƒä½çš„åœ°å€ä¼ ç»™æŒ
             -‡é’ˆ
  56   5                  for(count=0;count<14;count++)
  57   5                  {
  58   6                    LCD1602_Writecom(0X18);//æ•´å±å·¦ç§»
  59   6                    Delay_500ms();
  60   6                  }
  61   5              }
  62   4              else if(rece_buf[6]=='3')//ç”¨æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®
  63   4              {
  64   5                // sendstring("Display on the digital_control\n");
  65   5                for(count=0;count<8;count++)
  66   5                {
  67   6                  switch(count)  //ä½é€‰ï¼Œé€‰æ‹©ç‚¹äº®çš„æ•°ç ç®¡ï¼Œ
  68   6                  {
  69   7                    case(0):
  70   7                      LSA=0;LSB=0;LSC=0; break;//æ˜¾ç¤ºç¬¬0ä½
  71   7                    case(1):
  72   7                      LSA=1;LSB=0;LSC=0; break;//æ˜¾ç¤ºç¬¬1ä½
  73   7                    case(2):
  74   7                      LSA=0;LSB=1;LSC=0; break;//æ˜¾ç¤ºç¬¬2ä½
  75   7                    case(3):
  76   7                      LSA=1;LSB=1;LSC=0; break;//æ˜¾ç¤ºç¬¬3ä½
  77   7                    case(4):
  78   7                      LSA=0;LSB=0;LSC=1; break;//æ˜¾ç¤ºç¬¬4ä½
  79   7                    case(5):
  80   7                      LSA=1;LSB=0;LSC=1; break;//æ˜¾ç¤ºç¬¬5ä½
  81   7                    case(6):
  82   7                      LSA=0;LSB=1;LSC=1; break;//æ˜¾ç¤ºç¬¬6ä½
  83   7                    case(7):
  84   7                      LSA=1;LSB=1;LSC=1; break;//æ˜¾ç¤ºç¬¬7ä½
  85   7                  }
  86   6                  if(rece_buf[count+7]<='9')
  87   6                    DIG_GPIO_DUAN=DIG_CODE[rece_buf[count+7]-'0'];
  88   6                  else if(rece_buf[count+7]<='f'&&rece_buf[count+7]>='a')
  89   6                    DIG_GPIO_DUAN=DIG_CODE[rece_buf[count+7]-'a'+10];
  90   6                  else if(rece_buf[count+7]<='F'&&rece_buf[count+7]>='A')
  91   6                    DIG_GPIO_DUAN=DIG_CODE[rece_buf[count+7]-'A'+10];
  92   6                  i=500;  //æ¶ˆæŠ–
  93   6                  while(i--);
  94   6                }
  95   5              }
  96   4              else if (rece_buf[6]=='4')//ä»EEPROMä¸­è¯»å–æ•°æ®ï¼Œå¹¶ç”¨LCD1602æ˜¾ç¤ºå‡ºæ¥
  97   4              {
  98   5                if(flag_4)
  99   5                {
 100   6                  // sendstring("display and read from EEPROM\n");
 101   6                  LCD1602_Writestring("Read:");
 102   6                  for(count=0;rece_buf[count+7]!='\0';count++)
 103   6                  {
 104   7                    LCD1602_Writedata(AT24C02_read(count));
 105   7                  }
 106   6                  flag_4=0;
 107   6                }
 108   5              }
 109   4              else
 110   4              {
 111   5                sendstring("Please check the fifth character(0-4)\n");
 112   5              }
C51 COMPILER V9.01   MAIN                                                                  08/20/2016 14:19:38 PAGE 3   

 113   4             }
 114   3           }
 115   2         }
 116   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    444    ----
   CONSTANT SIZE    =    104    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     32       2
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
