C51 COMPILER V9.01   MAIN                                                                  08/19/2016 13:17:04 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c COMPACT DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <reg51.h>
   2          #include "delay.h"
   3          #include "LCD1602.h"
   4          #include "I2C.h"
   5          #include "EEPROM.h"
   6          #include "NRF2401.h"
   7          #define GPIO_KEY P1
   8          #define DIG_GPIO_DUAN P3
   9          #define DIG_GPIO_WEI P1
  10          
  11          sbit NRF_IR  = P0^2;
  12          
  13          unsigned char rece_buf[32];
  14          unsigned char code DIG_PLACE[8]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};//ä½é€‰æ§åˆ¶   æŸ¥è¡¨çš„æ–¹æ³•
             -æ§åˆ¶
  15          unsigned char code DIG_CODE[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x7
             -9,0x71};  //0~Fçš„æ˜¾ç¤ºç 
  16          
  17          
  18          int main(void)
  19          {
  20   1        unsigned char count,i;
  21   1        unsigned char rece_buf[32]="8>52103876cADf857";
  22   1        LCD1602_Init();// LCDåˆå§‹åŒ–
  23   1      //  while(NRF24L01_Check()); // ç­‰å¾…æ£€æµ‹åˆ°NRF24L01ï¼Œç¨‹åºæ‰ä¼šå‘ä¸‹æ‰§è¡Œ
  24   1        NRF24L01_RT_Init();
  25   1        // LCD1602_Writestring(test+7);
  26   1        while(1)
  27   1        {
  28   2      
  29   2          if(NRF_IR==0)   // å¦‚æœæ— çº¿æ¨¡å—æ¥æ”¶åˆ°æ•°æ®
  30   2          {
  31   3            // if(NRF24L01_RxPacket(rece_buf)==0)
  32   3            {
  33   4              if(rece_buf[1]!='>')
  34   4              {
  35   5                sendstring("Please start with >\n");
  36   5              }
  37   4              else if(rece_buf[2]!='5'&&\
  38   4                      rece_buf[3]!='2'&&\
  39   4                      rece_buf[4]!='1'&&\
  40   4                      rece_buf[5]!='0'
  41   4                     )return -1;
  42   4              if(rece_buf[6]=='1')//æ˜¾ç¤ºå‘é€æ•°æ®å¹¶æŠŠæ•°æ®ä¿å­˜åˆ°EEPROMé‡Œé¢
  43   4              {
  44   5                LCD1602_Writestring(rece_buf+7);//ä»ç¬¬ä¸ƒä½å¼€å§‹æ˜¾ç¤ºæ•°æ®,æŠŠç¬¬ä¸ƒä½çš„åœ°å€ä¼ ç»™æŒ‡é
             -’ˆ
  45   5                AT24C02_writestring(rece_buf+7);//ä»ç¬¬ä¸ƒä½å¼€å§‹ä¿å­˜æ•°æ®,æŠŠç¬¬ä¸ƒä½çš„åœ°å€ä¼ ç»™æŒ‡é
             -’ˆ
  46   5              }
  47   4              else if(rece_buf[6]=='2')//å±å¹•å·¦ç§»
  48   4              {
  49   5                  LCD1602_Writestring(rece_buf+7);//ä»ç¬¬ä¸ƒä½å¼€å§‹æ˜¾ç¤ºæ•°æ®,æŠŠç¬¬ä¸ƒä½çš„åœ°å€ä¼ ç»™æŒ
             -‡é’ˆ
  50   5                  for(count=0;count<14;count++)
C51 COMPILER V9.01   MAIN                                                                  08/19/2016 13:17:04 PAGE 2   

  51   5                  {
  52   6                    LCD1602_Writecom(0X18);//æ•´å±å·¦ç§»
  53   6                    Delay_500ms();
  54   6                  }
  55   5              }
  56   4              else if(rece_buf[6]=='3')//ç”¨æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®
  57   4              {
  58   5                for(count=0;count<8;count++)
  59   5                {
  60   6                  DIG_GPIO_WEI=DIG_PLACE[count];
  61   6                  if(rece_buf[count+7]<='9')
  62   6                    DIG_GPIO_DUAN=DIG_CODE[rece_buf[count+7]-'0'];
  63   6                  else if(rece_buf[count+7]<='f'&&rece_buf[count+7]>='a')
  64   6                    DIG_GPIO_DUAN=DIG_CODE[rece_buf[count+7]-'a'+10];
  65   6                  else if(rece_buf[count+7]<='F'&&rece_buf[count+7]>='A')
  66   6                    DIG_GPIO_DUAN=DIG_CODE[rece_buf[count+7]-'A'+10];
  67   6                  i=500;
  68   6                  while(i--);
  69   6                }
  70   5              }
  71   4              else if (rece_buf[6]=='4')//ä»EEPROMä¸­è¯»å–æ•°æ®ï¼Œå¹¶ç”¨LCD1602æ˜¾ç¤ºå‡ºæ¥
  72   4              {
  73   5                LCD1602_Writedata('4');
  74   5                for(count=0;rece_buf[count+7]!='\0';count++)
  75   5                LCD1602_Writedata(AT24C02_read(count));
  76   5                return ;
  77   5              }
  78   4              else
  79   4              {
  80   5                sendstring("Please check the fifth character(0-4)\n");
  81   5              }
  82   4             }
  83   3           }
  84   2         }
  85   1      }
*** WARNING C291 IN LINE 85 OF MAIN.C: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    295    ----
   CONSTANT SIZE    =    117    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     32      33
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
