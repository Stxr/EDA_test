C51 COMPILER V9.01   NRF2401                                                               08/21/2016 09:48:01 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NRF2401
OBJECT MODULE PLACED IN NRF2401.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE NRF2401.c COMPACT DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /**********************************************************/
   2          /* 名   称：NRF24L01+无线USB通信模块程序                  */
   3          /* 功   能：发送接收测试程序                              */
   4          /*          格式：首位是个数，后面跟要发送的数据          */
   5          /*                例如：发送5个字节 11 22 33 44 55(16进制)*/
   6          /*                电脑串口发送：1122334455                */
   7          /*                模块实际发送：051122334455              */
   8          /* 作者：BQDZ     （论坛：http://bqdz.taobao.com）        */
   9          /* 联系方式： QQ :851968194     旺旺：王亚坤2864          */
  10          /*           手机：15821472722（上海）                    */
  11          /**********************************************************/
  12          #include "NRF2401.h"
  13          
  14          const uchar TX_ADDRESS[TX_ADR_WIDTH]={0xFF,0xFF,0xFF,0xFF,0xFF}; //发送地址
  15          const uchar RX_ADDRESS[RX_ADR_WIDTH]={0xFF,0xFF,0xFF,0xFF,0xFF}; //发送地址
  16          
  17          
  18          // sbit LED=P1^0;
  19          //
  20          // sbit S1=P3^2;
  21          // sbit S2=P3^4;
  22          // uchar rece_buf[32];
  23          sbit NRF_CE   = P3^0;
  24          sbit NRF_SCK  = P3^1;
  25          sbit NRF_MISO = P3^2;
  26          sbit NRF_CSN  = P3^3;
  27          sbit NRF_MOSI = P3^4;
  28          sbit NRF_IRQ  = P3^5;
  29          
  30          void delay_us(uchar num)
  31          {
  32   1        uchar i;
  33   1        for(i=0;i<num;i++)
  34   1        _nop_();
  35   1      }
  36          void delay_150us()
  37          {
  38   1        uint i;
  39   1      
  40   1        for(i=0;i<150;i++);
  41   1      }
  42          /***************************************************************/
  43          
  44          /*******************************************************************/
  45          uchar SPI_RW(uchar byte)
  46          {
  47   1        uchar bit_ctr;
  48   1        for(bit_ctr=0;bit_ctr<8;bit_ctr++)  // 输出8位
  49   1        {
  50   2          NRF_MOSI=(byte&0x80);       // MSB TO MOSI
  51   2          byte=(byte<<1);         // shift next bit to MSB
  52   2          NRF_SCK=1;
  53   2          byte|=NRF_MISO;             // capture current MISO bit
  54   2          NRF_SCK=0;
  55   2        }
C51 COMPILER V9.01   NRF2401                                                               08/21/2016 09:48:01 PAGE 2   

  56   1        return byte;
  57   1      }
  58          
  59          /*********************************************/
  60          /* 函数功能：给24L01的寄存器写值（一个字节） */
  61          /* 入口参数：reg   要写的寄存器地址          */
  62          /*           value 给寄存器写的值            */
  63          /* 出口参数：status 状态值                   */
  64          /*********************************************/
  65          uchar NRF24L01_Write_Reg(uchar reg,uchar value)
  66          {
  67   1        uchar status;
  68   1      
  69   1        NRF_CSN=0;                  //CSN=0;
  70   1          status = SPI_RW(reg);   //发送寄存器地址,并读取状态值
  71   1        SPI_RW(value);
  72   1        NRF_CSN=1;                  //CSN=1;
  73   1      
  74   1        return status;
  75   1      }
  76          /*************************************************/
  77          /* 函数功能：读24L01的寄存器值 （一个字节）      */
  78          /* 入口参数：reg  要读的寄存器地址               */
  79          /* 出口参数：value 读出寄存器的值                */
  80          /*************************************************/
  81          uchar NRF24L01_Read_Reg(uchar reg)
  82          {
  83   1        uchar value;
  84   1      
  85   1        NRF_CSN=0;              //CSN=0;
  86   1          SPI_RW(reg);      //发送寄存器值(位置),并读取状态值
  87   1        value = SPI_RW(NOP);
  88   1        NRF_CSN=1;              //CSN=1;
  89   1      
  90   1        return value;
  91   1      }
  92          /*********************************************/
  93          /* 函数功能：读24L01的寄存器值（多个字节）   */
  94          /* 入口参数：reg   寄存器地址                */
  95          /*           *pBuf 读出寄存器值的存放数组    */
  96          /*           len   数组字节长度              */
  97          /* 出口参数：status 状态值                   */
  98          /*********************************************/
  99          uchar NRF24L01_Read_Buf(uchar reg,uchar *pBuf,uchar len)
 100          {
 101   1        uchar status,u8_ctr;
 102   1        NRF_CSN=0;                    //CSN=0
 103   1          status=SPI_RW(reg);       //发送寄存器地址,并读取状态值
 104   1        for(u8_ctr=0;u8_ctr<len;u8_ctr++)
 105   1        pBuf[u8_ctr]=SPI_RW(0XFF);    //读出数据
 106   1        NRF_CSN=1;                    //CSN=1
 107   1          return status;              //返回读到的状态值
 108   1      }
 109          /**********************************************/
 110          /* 函数功能：给24L01的寄存器写值（多个字节）  */
 111          /* 入口参数：reg  要写的寄存器地址            */
 112          /*           *pBuf 值的存放数组               */
 113          /*           len   数组字节长度               */
 114          /**********************************************/
 115          uchar NRF24L01_Write_Buf(uchar reg, uchar *pBuf, uchar len)
 116          {
 117   1        uchar status,u8_ctr;
C51 COMPILER V9.01   NRF2401                                                               08/21/2016 09:48:01 PAGE 3   

 118   1        NRF_CSN=0;
 119   1          status = SPI_RW(reg);     //发送寄存器值(位置),并读取状态值
 120   1          for(u8_ctr=0; u8_ctr<len; u8_ctr++)
 121   1        SPI_RW(*pBuf++);        //写入数据
 122   1        NRF_CSN=1;
 123   1          return status;              //返回读到的状态值
 124   1      }
 125          
 126          /*********************************************/
 127          /* 函数功能：24L01接收数据                   */
 128          /* 入口参数：rxbuf 接收数据数组              */
 129          /* 返回值： 0   成功收到数据                 */
 130          /*          1   没有收到数据                 */
 131          /*********************************************/
 132          uchar NRF24L01_RxPacket(uchar *rxbuf)
 133          {
 134   1        uchar state;
 135   1      
 136   1        state=NRF24L01_Read_Reg(STATUS);        //读取状态寄存器的值
 137   1        NRF24L01_Write_Reg(WRITE_REG+STATUS,state); //清除TX_DS或MAX_RT中断标志
 138   1        if(state&RX_OK)               //接收到数据
 139   1        {
 140   2          NRF_CE = 0;
 141   2          NRF24L01_Read_Buf(RD_RX_PLOAD,rxbuf,RX_PLOAD_WIDTH);//读取数据
 142   2          NRF24L01_Write_Reg(FLUSH_RX,0xff);          //清除RX FIFO寄存器
 143   2          NRF_CE = 1;
 144   2          delay_150us();
 145   2          return 0;
 146   2        }
 147   1        return 1;//没收到任何数据
 148   1      }
 149          /**********************************************/
 150          /* 函数功能：设置24L01为发送模式              */
 151          /* 入口参数：txbuf  发送数据数组              */
 152          /* 返回值； 0x10    达到最大重发次数，发送失败*/
 153          /*          0x20    成功发送完成              */
 154          /*          0xff    发送失败                  */
 155          /**********************************************/
 156          uchar NRF24L01_TxPacket(uchar *txbuf)
 157          {
 158   1        uchar state;
 159   1      
 160   1        NRF_CE=0;                       //CE拉低，使能24L01配置
 161   1          NRF24L01_Write_Buf(WR_TX_PLOAD,txbuf,TX_PLOAD_WIDTH); //写数据到TX BUF  32个字节
 162   1        NRF_CE=1;                       //CE置高，使能发送
 163   1        while(NRF_IRQ==1);                    //等待发送完成
 164   1        state=NRF24L01_Read_Reg(STATUS);              //读取状态寄存器的值
 165   1        NRF24L01_Write_Reg(WRITE_REG+STATUS,state);       //清除TX_DS或MAX_RT中断标志
 166   1        if(state&MAX_TX)                    //达到最大重发次数
 167   1        {
 168   2          NRF24L01_Write_Reg(FLUSH_TX,0xff);          //清除TX FIFO寄存器
 169   2          return MAX_TX;
 170   2        }
 171   1        if(state&TX_OK)                     //发送完成
 172   1        {
 173   2          return TX_OK;
 174   2        }
 175   1        return 0xff;                      //发送失败
 176   1      }
 177          
 178          /********************************************/
 179          /* 函数功能：检测24L01是否存在              */
C51 COMPILER V9.01   NRF2401                                                               08/21/2016 09:48:01 PAGE 4   

 180          /* 返回值；  0  存在                        */
 181          /*           1  不存在                      */
 182          /********************************************/
 183          uchar NRF24L01_Check(void)
 184          {
 185   1        uchar check_in_buf[5]={0x11,0x22,0x33,0x44,0x55};
 186   1        uchar check_out_buf[5]={0x00};
 187   1      
 188   1        NRF_SCK=0;
 189   1        NRF_CSN=1;
 190   1        NRF_CE=0;
 191   1      
 192   1        NRF24L01_Write_Buf(WRITE_REG+TX_ADDR, check_in_buf, 5);
 193   1      
 194   1        NRF24L01_Read_Buf(READ_REG+TX_ADDR, check_out_buf, 5);
 195   1      
 196   1        if((check_out_buf[0] == 0x11)&&\
 197   1           (check_out_buf[1] == 0x22)&&\
 198   1           (check_out_buf[2] == 0x33)&&\
 199   1           (check_out_buf[3] == 0x44)&&\
 200   1           (check_out_buf[4] == 0x55))return 0;
 201   1        else return 1;
 202   1      }
 203          
 204          
 205          void NRF24L01_RT_Init(void)
 206          {
 207   1        NRF_CE=0;
 208   1          NRF24L01_Write_Reg(WRITE_REG+RX_PW_P0,RX_PLOAD_WIDTH);//选择通道0的有效数据宽度
 209   1          NRF24L01_Write_Reg(FLUSH_RX,0xff);                  //清除RX FIFO寄存器
 210   1          NRF24L01_Write_Buf(WRITE_REG+TX_ADDR,(uchar*)TX_ADDRESS,TX_ADR_WIDTH);//写TX节点地址
 211   1          NRF24L01_Write_Buf(WRITE_REG+RX_ADDR_P0,(uchar*)RX_ADDRESS,RX_ADR_WIDTH); //设置TX节点地址,主要
             -为了使能ACK
 212   1          NRF24L01_Write_Reg(WRITE_REG+EN_AA,0x01);     //使能通道0的自动应答
 213   1          NRF24L01_Write_Reg(WRITE_REG+EN_RXADDR,0x01); //使能通道0的接收地址
 214   1          NRF24L01_Write_Reg(WRITE_REG+SETUP_RETR,0x1a);//设置自动重发间隔时间:500us + 86us;最大自
             -重发次数:10次
 215   1          NRF24L01_Write_Reg(WRITE_REG+RF_CH,0);        //设置RF通道为2.400GHz  频率=2.4+0GHz
 216   1          NRF24L01_Write_Reg(WRITE_REG+RF_SETUP,0x0F);  //设置TX发射参数,0db增益,2Mbps,低噪声增益开
             -启
 217   1          NRF24L01_Write_Reg(WRITE_REG+CONFIG,0x0f);    //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_C
             -RC,接收模式,开启所有中断
 218   1        NRF_CE=1;                   //CE置高，使能发送
 219   1      }
 220          
 221          void SEND_BUF(char *buf)
 222          {
 223   1        NRF_CE=0;
 224   1        NRF24L01_Write_Reg(WRITE_REG+CONFIG,0x0e);
 225   1        NRF_CE=1;
 226   1        delay_us(15);
 227   1        NRF24L01_TxPacket(buf);
 228   1        NRF_CE=0;
 229   1        NRF24L01_Write_Reg(WRITE_REG+CONFIG, 0x0f);
 230   1        NRF_CE=1;
 231   1      }
 232          // int main(void)
 233          // {
 234          //  while(NRF24L01_Check()); // 等待检测到NRF24L01，程序才会向下执行
 235          //  NRF24L01_RT_Init();
 236          //  while(1)
 237          //  {
C51 COMPILER V9.01   NRF2401                                                               08/21/2016 09:48:01 PAGE 5   

 238          //    if(NRF_IRQ==0)    // 如果无线模块接收到数据
 239          //    {
 240          //      if(NRF24L01_RxPacket(rece_buf)==0)
 241          //      {
 242          //        // tcnt=rece_buf[0];
 243          //        // rece_buf[1]=tcnt+0x30;
 244          //        // rece_buf[0]=1;
 245          //        // SEND_BUF(rece_buf);
 246          //        Sendlength(rece_buf);
 247          //      }
 248          //    }
 249          //  }
 250          //  return 0;
 251          // }
 252          void Sendlength(uchar *buff)
 253          {
 254   1        int length,count=0;
 255   1        length=strlen(buff);
 256   1        buff[0]=intlen(length-1) ;//发送数组的最高位数
 257   1        Int_to_char(length-1,buff);
 258   1        SEND_BUF(buff);
 259   1      }
 260          int intlen(int num)//计算int类型的数的长度
 261          {
 262   1        int count=0;
 263   1        while(num)
 264   1        {
 265   2          count++;
 266   2          num/=10;
 267   2        }
 268   1        return count;
 269   1      }
 270          void Int_to_char(int num,char *buffer)//将整数拆开放入数组里
 271          {
 272   1        int i=0;
 273   1        for(i=intlen(num);i>0;i--)
 274   1        {
 275   2          buffer[i]=(num)%10+0x30;
 276   2          num/=10;
 277   2        }
 278   1      }
 279          void sendstring(uchar *buffer)//发送数组
 280          {
 281   1        int i;
 282   1        char buffer1[32];
 283   1        for(i=strlen(buffer)-1;i>=0;i--)
 284   1        {
 285   2          buffer1[i+1]=buffer[i];
 286   2        }
 287   1        buffer1[0]=strlen(buffer);
 288   1        SEND_BUF(buffer1);
 289   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    859    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     10      74
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.01   NRF2401                                                               08/21/2016 09:48:01 PAGE 6   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
