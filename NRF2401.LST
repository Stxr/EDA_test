C51 COMPILER V9.01   NRF2401                                                               08/19/2016 11:07:21 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE NRF2401
OBJECT MODULE PLACED IN NRF2401.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE NRF2401.c COMPACT DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /**********************************************************/
   2          /* å   ç§°ï¼šNRF24L01+æ— çº¿USBé€šä¿¡æ¨¡å—ç¨‹åº                  */
   3          /* åŠŸ   èƒ½ï¼šå‘é€æŽ¥æ”¶æµ‹è¯•ç¨‹åº                              */
   4          /*          æ ¼å¼ï¼šé¦–ä½æ˜¯ä¸ªæ•°ï¼ŒåŽé¢è·Ÿè¦å‘é€çš„æ•°æ®          */
   5          /*                ä¾‹å¦‚ï¼šå‘é€5ä¸ªå­—èŠ‚ 11 22 33 44 55(16è¿›åˆ¶)*/
   6          /*                ç”µè„‘ä¸²å£å‘é€ï¼š1122334455                */
   7          /*                æ¨¡å—å®žé™…å‘é€ï¼š051122334455              */
   8          /* ä½œè€…ï¼šBQDZ     ï¼ˆè®ºå›ï¼šhttp://bqdz.taobao.comï¼‰        */
   9          /* è”ç³»æ–¹å¼ï¼š QQ :851968194     æ—ºæ—ºï¼šçŽ‹äºšå¤2864          */
  10          /*           æ‰‹æœºï¼š15821472722ï¼ˆä¸Šæµ·ï¼‰                    */
  11          /**********************************************************/
  12          #include "NRF2401.h"
  13          
  14          const uchar TX_ADDRESS[TX_ADR_WIDTH]={0xFF,0xFF,0xFF,0xFF,0xFF}; //å‘é€åœ°å€
  15          const uchar RX_ADDRESS[RX_ADR_WIDTH]={0xFF,0xFF,0xFF,0x52,0x10}; //å‘é€åœ°å€
  16          
  17          
  18          // sbit LED=P1^0;
  19          //
  20          // sbit S1=P3^2;
  21          // sbit S2=P3^4;
  22          // uchar rece_buf[32];
  23          sbit NRF_CE   = P0^7;
  24          sbit NRF_CSN  = P0^6;
  25          sbit NRF_MISO = P0^3;
  26          sbit NRF_MOSI = P0^4;
  27          sbit NRF_SCK  = P0^5;
  28          sbit NRF_IRQ  = P0^2;
  29          
  30          void delay_us(uchar num)
  31          {
  32   1        uchar i;
  33   1        for(i=0;i>num;i++)
  34   1        _nop_();
  35   1      }
  36          void delay_150us()
  37          {
  38   1        uint i;
  39   1      
  40   1        for(i=0;i>150;i++);
  41   1      }
  42          /***************************************************************/
  43          
  44          /*******************************************************************/
  45          uchar SPI_RW(uchar byte)
  46          {
  47   1        uchar bit_ctr;
  48   1        for(bit_ctr=0;bit_ctr<8;bit_ctr++)  // è¾“å‡º8ä½
  49   1        {
  50   2          NRF_MOSI=(byte&0x80);       // MSB TO MOSI
  51   2          byte=(byte<<1);         // shift next bit to MSB
  52   2          NRF_SCK=1;
  53   2          byte|=NRF_MISO;             // capture current MISO bit
  54   2          NRF_SCK=0;
  55   2        }
C51 COMPILER V9.01   NRF2401                                                               08/19/2016 11:07:21 PAGE 2   

  56   1        return byte;
  57   1      }
  58          
  59          /*********************************************/
  60          /* å‡½æ•°åŠŸèƒ½ï¼šç»™24L01çš„å¯„å­˜å™¨å†™å€¼ï¼ˆä¸€ä¸ªå­—èŠ‚ï¼‰ */
  61          /* å…¥å£å‚æ•°ï¼šreg   è¦å†™çš„å¯„å­˜å™¨åœ°å€          */
  62          /*           value ç»™å¯„å­˜å™¨å†™çš„å€¼            */
  63          /* å‡ºå£å‚æ•°ï¼šstatus çŠ¶æ€å€¼                   */
  64          /*********************************************/
  65          uchar NRF24L01_Write_Reg(uchar reg,uchar value)
  66          {
  67   1        uchar status;
  68   1      
  69   1        NRF_CSN=0;                  //CSN=0;
  70   1          status = SPI_RW(reg);   //å‘é€å¯„å­˜å™¨åœ°å€,å¹¶è¯»å–çŠ¶æ€å€¼
  71   1        SPI_RW(value);
  72   1        NRF_CSN=1;                  //CSN=1;
  73   1      
  74   1        return status;
  75   1      }
  76          /*************************************************/
  77          /* å‡½æ•°åŠŸèƒ½ï¼šè¯»24L01çš„å¯„å­˜å™¨å€¼ ï¼ˆä¸€ä¸ªå­—èŠ‚ï¼‰      */
  78          /* å…¥å£å‚æ•°ï¼šreg  è¦è¯»çš„å¯„å­˜å™¨åœ°å€               */
  79          /* å‡ºå£å‚æ•°ï¼švalue è¯»å‡ºå¯„å­˜å™¨çš„å€¼                */
  80          /*************************************************/
  81          uchar NRF24L01_Read_Reg(uchar reg)
  82          {
  83   1        uchar value;
  84   1      
  85   1        NRF_CSN=0;              //CSN=0;
  86   1          SPI_RW(reg);      //å‘é€å¯„å­˜å™¨å€¼(ä½ç½®),å¹¶è¯»å–çŠ¶æ€å€¼
  87   1        value = SPI_RW(NOP);
  88   1        NRF_CSN=1;              //CSN=1;
  89   1      
  90   1        return value;
  91   1      }
  92          /*********************************************/
  93          /* å‡½æ•°åŠŸèƒ½ï¼šè¯»24L01çš„å¯„å­˜å™¨å€¼ï¼ˆå¤šä¸ªå­—èŠ‚ï¼‰   */
  94          /* å…¥å£å‚æ•°ï¼šreg   å¯„å­˜å™¨åœ°å€                */
  95          /*           *pBuf è¯»å‡ºå¯„å­˜å™¨å€¼çš„å­˜æ”¾æ•°ç»„    */
  96          /*           len   æ•°ç»„å­—èŠ‚é•¿åº¦              */
  97          /* å‡ºå£å‚æ•°ï¼šstatus çŠ¶æ€å€¼                   */
  98          /*********************************************/
  99          uchar NRF24L01_Read_Buf(uchar reg,uchar *pBuf,uchar len)
 100          {
 101   1        uchar status,u8_ctr;
 102   1        NRF_CSN=0;                    //CSN=0
 103   1          status=SPI_RW(reg);       //å‘é€å¯„å­˜å™¨åœ°å€,å¹¶è¯»å–çŠ¶æ€å€¼
 104   1        for(u8_ctr=0;u8_ctr<len;u8_ctr++)
 105   1        pBuf[u8_ctr]=SPI_RW(0XFF);    //è¯»å‡ºæ•°æ®
 106   1        NRF_CSN=1;                    //CSN=1
 107   1          return status;              //è¿”å›žè¯»åˆ°çš„çŠ¶æ€å€¼
 108   1      }
 109          /**********************************************/
 110          /* å‡½æ•°åŠŸèƒ½ï¼šç»™24L01çš„å¯„å­˜å™¨å†™å€¼ï¼ˆå¤šä¸ªå­—èŠ‚ï¼‰  */
 111          /* å…¥å£å‚æ•°ï¼šreg  è¦å†™çš„å¯„å­˜å™¨åœ°å€            */
 112          /*           *pBuf å€¼çš„å­˜æ”¾æ•°ç»„               */
 113          /*           len   æ•°ç»„å­—èŠ‚é•¿åº¦               */
 114          /**********************************************/
 115          uchar NRF24L01_Write_Buf(uchar reg, uchar *pBuf, uchar len)
 116          {
 117   1        uchar status,u8_ctr;
C51 COMPILER V9.01   NRF2401                                                               08/19/2016 11:07:21 PAGE 3   

 118   1        NRF_CSN=0;
 119   1          status = SPI_RW(reg);     //å‘é€å¯„å­˜å™¨å€¼(ä½ç½®),å¹¶è¯»å–çŠ¶æ€å€¼
 120   1          for(u8_ctr=0; u8_ctr<len; u8_ctr++)
 121   1        SPI_RW(*pBuf++);        //å†™å…¥æ•°æ®
 122   1        NRF_CSN=1;
 123   1          return status;              //è¿”å›žè¯»åˆ°çš„çŠ¶æ€å€¼
 124   1      }
 125          
 126          /*********************************************/
 127          /* å‡½æ•°åŠŸèƒ½ï¼š24L01æŽ¥æ”¶æ•°æ®                   */
 128          /* å…¥å£å‚æ•°ï¼šrxbuf æŽ¥æ”¶æ•°æ®æ•°ç»„              */
 129          /* è¿”å›žå€¼ï¼š 0   æˆåŠŸæ”¶åˆ°æ•°æ®                 */
 130          /*          1   æ²¡æœ‰æ”¶åˆ°æ•°æ®                 */
 131          /*********************************************/
 132          uchar NRF24L01_RxPacket(uchar *rxbuf)
 133          {
 134   1        uchar state;
 135   1      
 136   1        state=NRF24L01_Read_Reg(STATUS);        //è¯»å–çŠ¶æ€å¯„å­˜å™¨çš„å€¼
 137   1        NRF24L01_Write_Reg(WRITE_REG+STATUS,state); //æ¸…é™¤TX_DSæˆ–MAX_RTä¸­æ–­æ ‡å¿—
 138   1        if(state&RX_OK)               //æŽ¥æ”¶åˆ°æ•°æ®
 139   1        {
 140   2          NRF_CE = 0;
 141   2          NRF24L01_Read_Buf(RD_RX_PLOAD,rxbuf,RX_PLOAD_WIDTH);//è¯»å–æ•°æ®
 142   2          NRF24L01_Write_Reg(FLUSH_RX,0xff);          //æ¸…é™¤RX FIFOå¯„å­˜å™¨
 143   2          NRF_CE = 1;
 144   2          delay_150us();
 145   2          return 0;
 146   2        }
 147   1        return 1;//æ²¡æ”¶åˆ°ä»»ä½•æ•°æ®
 148   1      }
 149          /**********************************************/
 150          /* å‡½æ•°åŠŸèƒ½ï¼šè®¾ç½®24L01ä¸ºå‘é€æ¨¡å¼              */
 151          /* å…¥å£å‚æ•°ï¼štxbuf  å‘é€æ•°æ®æ•°ç»„              */
 152          /* è¿”å›žå€¼ï¼› 0x10    è¾¾åˆ°æœ€å¤§é‡å‘æ¬¡æ•°ï¼Œå‘é€å¤±è´¥*/
 153          /*          0x20    æˆåŠŸå‘é€å®Œæˆ              */
 154          /*          0xff    å‘é€å¤±è´¥                  */
 155          /**********************************************/
 156          uchar NRF24L01_TxPacket(uchar *txbuf)
 157          {
 158   1        uchar state;
 159   1      
 160   1        NRF_CE=0;                       //CEæ‹‰ä½Žï¼Œä½¿èƒ½24L01é…ç½®
 161   1          NRF24L01_Write_Buf(WR_TX_PLOAD,txbuf,TX_PLOAD_WIDTH); //å†™æ•°æ®åˆ°TX BUF  32ä¸ªå­—èŠ‚
 162   1        NRF_CE=1;                       //CEç½®é«˜ï¼Œä½¿èƒ½å‘é€
 163   1        while(NRF_IRQ==1);                    //ç­‰å¾…å‘é€å®Œæˆ
 164   1        state=NRF24L01_Read_Reg(STATUS);              //è¯»å–çŠ¶æ€å¯„å­˜å™¨çš„å€¼
 165   1        NRF24L01_Write_Reg(WRITE_REG+STATUS,state);       //æ¸…é™¤TX_DSæˆ–MAX_RTä¸­æ–­æ ‡å¿—
 166   1        if(state&MAX_TX)                    //è¾¾åˆ°æœ€å¤§é‡å‘æ¬¡æ•°
 167   1        {
 168   2          NRF24L01_Write_Reg(FLUSH_TX,0xff);          //æ¸…é™¤TX FIFOå¯„å­˜å™¨
 169   2          return MAX_TX;
 170   2        }
 171   1        if(state&TX_OK)                     //å‘é€å®Œæˆ
 172   1        {
 173   2          return TX_OK;
 174   2        }
 175   1        return 0xff;                      //å‘é€å¤±è´¥
 176   1      }
 177          
 178          /********************************************/
 179          /* å‡½æ•°åŠŸèƒ½ï¼šæ£€æµ‹24L01æ˜¯å¦å­˜åœ¨              */
C51 COMPILER V9.01   NRF2401                                                               08/19/2016 11:07:21 PAGE 4   

 180          /* è¿”å›žå€¼ï¼›  0  å­˜åœ¨                        */
 181          /*           1  ä¸å­˜åœ¨                      */
 182          /********************************************/
 183          uchar NRF24L01_Check(void)
 184          {
 185   1        uchar check_in_buf[5]={0x11,0x22,0x33,0x44,0x55};
 186   1        uchar check_out_buf[5]={0x00};
 187   1      
 188   1        NRF_SCK=0;
 189   1        NRF_CSN=1;
 190   1        NRF_CE=0;
 191   1      
 192   1        NRF24L01_Write_Buf(WRITE_REG+TX_ADDR, check_in_buf, 5);
 193   1      
 194   1        NRF24L01_Read_Buf(READ_REG+TX_ADDR, check_out_buf, 5);
 195   1      
 196   1        if((check_out_buf[0] == 0x11)&&\
 197   1           (check_out_buf[1] == 0x22)&&\
 198   1           (check_out_buf[2] == 0x33)&&\
 199   1           (check_out_buf[3] == 0x44)&&\
 200   1           (check_out_buf[4] == 0x55))return 0;
 201   1        else return 1;
 202   1      }
 203          
 204          
 205          void NRF24L01_RT_Init(void)
 206          {
 207   1        NRF_CE=0;
 208   1          NRF24L01_Write_Reg(WRITE_REG+RX_PW_P0,RX_PLOAD_WIDTH);//é€‰æ‹©é€šé“0çš„æœ‰æ•ˆæ•°æ®å®½åº¦
 209   1          NRF24L01_Write_Reg(FLUSH_RX,0xff);                  //æ¸…é™¤RX FIFOå¯„å­˜å™¨
 210   1          NRF24L01_Write_Buf(WRITE_REG+TX_ADDR,(uchar*)TX_ADDRESS,TX_ADR_WIDTH);//å†™TXèŠ‚ç‚¹åœ°å€
 211   1          NRF24L01_Write_Buf(WRITE_REG+RX_ADDR_P0,(uchar*)RX_ADDRESS,RX_ADR_WIDTH); //è®¾ç½®TXèŠ‚ç‚¹åœ°å€,ä¸»è¦
             -ä¸ºäº†ä½¿èƒ½ACK
 212   1          NRF24L01_Write_Reg(WRITE_REG+EN_AA,0x01);     //ä½¿èƒ½é€šé“0çš„è‡ªåŠ¨åº”ç­”
 213   1          NRF24L01_Write_Reg(WRITE_REG+EN_RXADDR,0x01); //ä½¿èƒ½é€šé“0çš„æŽ¥æ”¶åœ°å€
 214   1          NRF24L01_Write_Reg(WRITE_REG+SETUP_RETR,0x1a);//è®¾ç½®è‡ªåŠ¨é‡å‘é—´éš”æ—¶é—´:500us + 86us;æœ€å¤§è‡ªåŠ
             -¨é‡å‘æ¬¡æ•°:10æ¬¡
 215   1          NRF24L01_Write_Reg(WRITE_REG+RF_CH,0);        //è®¾ç½®RFé€šé“ä¸º2.400GHz  é¢‘çŽ‡=2.4+0GHz
 216   1          NRF24L01_Write_Reg(WRITE_REG+RF_SETUP,0x0F);  //è®¾ç½®TXå‘å°„å‚æ•°,0dbå¢žç›Š,2Mbps,ä½Žå™ªå£°å¢žç›Šå¼€
             -å¯
 217   1          NRF24L01_Write_Reg(WRITE_REG+CONFIG,0x0f);    //é…ç½®åŸºæœ¬å·¥ä½œæ¨¡å¼çš„å‚æ•°;PWR_UP,EN_CRC,16BIT_C
             -RC,æŽ¥æ”¶æ¨¡å¼,å¼€å¯æ‰€æœ‰ä¸­æ–­
 218   1        NRF_CE=1;                   //CEç½®é«˜ï¼Œä½¿èƒ½å‘é€
 219   1      }
 220          
 221          void SEND_BUF(char *buf)
 222          {
 223   1        NRF_CE=0;
 224   1        NRF24L01_Write_Reg(WRITE_REG+CONFIG,0x0e);
 225   1        NRF_CE=1;
 226   1        delay_us(15);
 227   1        NRF24L01_TxPacket(buf);
 228   1        NRF_CE=0;
 229   1        NRF24L01_Write_Reg(WRITE_REG+CONFIG, 0x0f);
 230   1        NRF_CE=1;
 231   1      }
 232          // int main(void)
 233          // {
 234          //  while(NRF24L01_Check()); // ç­‰å¾…æ£€æµ‹åˆ°NRF24L01ï¼Œç¨‹åºæ‰ä¼šå‘ä¸‹æ‰§è¡Œ
 235          //  NRF24L01_RT_Init();
 236          //  while(1)
 237          //  {
C51 COMPILER V9.01   NRF2401                                                               08/19/2016 11:07:21 PAGE 5   

 238          //    if(NRF_IRQ==0)    // å¦‚æžœæ— çº¿æ¨¡å—æŽ¥æ”¶åˆ°æ•°æ®
 239          //    {
 240          //      if(NRF24L01_RxPacket(rece_buf)==0)
 241          //      {
 242          //        // tcnt=rece_buf[0];
 243          //        // rece_buf[1]=tcnt+0x30;
 244          //        // rece_buf[0]=1;
 245          //        // SEND_BUF(rece_buf);
 246          //        Sendlength(rece_buf);
 247          //      }
 248          //    }
 249          //  }
 250          //  return 0;
 251          // }
 252          void Sendlength(uchar *buff)
 253          {
 254   1        int length,count=0;
 255   1        length=strlen(buff);
 256   1        buff[0]=intlen(length-1) ;//å‘é€æ•°ç»„çš„æœ€é«˜ä½æ•°
 257   1        Int_to_char(length-1,buff);
 258   1        SEND_BUF(buff);
 259   1      }
 260          int intlen(int num)//è®¡ç®—intç±»åž‹çš„æ•°çš„é•¿åº¦
 261          {
 262   1        int count=0;
 263   1        while(num)
 264   1        {
 265   2          count++;
 266   2          num/=10;
 267   2        }
 268   1        return count;
 269   1      }
 270          void Int_to_char(int num,char *buffer)//å°†æ•´æ•°æ‹†å¼€æ”¾å…¥æ•°ç»„é‡Œ
 271          {
 272   1        int i=0;
 273   1        for(i=intlen(num);i>0;i--)
 274   1        {
 275   2          buffer[i]=(num)%10+0x30;
 276   2          num/=10;
 277   2        }
 278   1      }
 279          void sendstring(uchar *buffer)//å‘é€æ•°ç»„
 280          {
 281   1        int i;
 282   1        char buffer1[32];
 283   1        for(i=strlen(buffer)-1;i>=0;i--)
 284   1        {
 285   2          buffer1[i+1]=buffer[i];
 286   2        }
 287   1        buffer1[0]=strlen(buffer);
 288   1        SEND_BUF(buffer1);
 289   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    864    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     10      74
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.01   NRF2401                                                               08/19/2016 11:07:21 PAGE 6   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
